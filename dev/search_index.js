var documenterSearchIndex = {"docs":
[{"location":"index.html#State-to-state-transfer-in-a-two-level-quantum-system","page":"Introduction","title":"State-to-state transfer in a two-level quantum system","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The goal of this example is misimise the cost","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"mathcalC = langle uparrow psi(t_f)rangle ^2 + fracgamma2 int_0^t_fu(t)^2mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"while we steer the system bettwen to states, uparrowrangle to downarrowrangle, described by following Hamiltonian:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"H(t) = fracDelta2 sigma_z + fracu(t)2 sigma_x","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The final time t_f is set equalt to 2pisqrt1+Delta^2;\npsi(t_f)\nis the state at the final time t_f;\ngamma\nis a factor to adjust the relative weight of the two terms in the cost\nDelta\nrepresents the frequency offset; \nu(t) in -u_0u_0\nis the control;\nsigma_zsigma_x\nare Pauli matrices. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The dynamics is governed by the Schr√∂dinger equation $ i\\hbar |\\dot{\\psi}\\rangle = H(t) |\\psi\\rangle. $  However, ths states here belong to a Hilber space mathcalH = mathbbC^2, which is not easy to visuzalize. To improve that, we can tranform in Bloch representation to have a real system. It can be shown applinng dot x_j = Hsigma_j , where  cdotcdot denote the Lie bracket. In other words,","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"\nbegincases\ndot x = -Delta cdot y\ndot y = Delta cdot x - u cdot z\ndot z = u cdot y\nendcases","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"with uparrowrangle = (001) to downarrowrangle= (00-1). Furthermore, we will set Delta = 05 and p_0= 01.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using OptimalControl  \nusing OrdinaryDiffEq  \nusing LinearAlgebra\nusing NLPModelsIpopt\n\n\nq0 = [0.0, 0.0, 1.0] \nqf = [0.0, 0.0, -1.0] \nŒî = 0.5\ntf = 2 * œÄ / (‚àö( 1 + Œî^2))\nŒ≥ = 0.1\n\n\nocp1 = @def begin\n    t ‚àà [0, tf], time\n    q = [x, y, z] ‚àà R¬≥, state\n    u ‚àà R, control\n    \n    q(0) == q0 \n    ‚àÇ(x)(t) == - Œî * y(t)\n    ‚àÇ(y)(t) == Œî * x(t) - u(t) * z(t)\n    ‚àÇ(z)(t) == u(t) * y(t)\n    sum((q(tf) - qf).^2) + (Œ≥ / 2) * ‚à´(u(t)^2) ‚Üí min\nend\nnothing # hide","category":"page"},{"location":"index.html#Direct-solve","page":"Introduction","title":"Direct solve","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"N = 100\ndirect_sol1 = solve(ocp1, grid_size=N)\nnothing #hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Plots\nplt = plot(direct_sol1)\nnothing #hide","category":"page"},{"location":"index.html#Indirect-solve","page":"Introduction","title":"Indirect solve","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We can also solve the problem with shooting thechincs. Using the Pontryagin‚Äôs Maximum Principle, the pseudo-Hamiltonian is given by","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"H_p(x p u) = Delta(p_yx - p_x y) + u(p_z y - p_yz)+ mathcalV fracgamma2 u^2","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where p = (p_x p_yp_z) is the costate vector. The optimal control is given by the maximization of H_p:  ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"    u  = fracp_zy - p_yzgamma","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Define the packages:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using MINPACK ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Define the control and Hamiltonian flow:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"# Control\nu(q, p) = (p[3] * q[2] - p[2] * q[3]) / Œ≥\n\n# Hamiltonian flow\nf = Flow(ocp1, u)\nnothing # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The shooting function enforces the conditions:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"    S  mathbbR^3 longrightarrow mathbbR^3 \n    S(p_0) = p(t_fq_0p_0) + 2(q(t_fx_0p_f)-q_f)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"p0 = direct_sol1.costate(0); \n\nfunction shoot!(s, p0)\n    qqf, pf = f(0, q0, p0, tf)\n    s[1:3] .= pf + 2(qqf - qf)\n    return nothing\nend\ns = similar(p0, 3)\nshoot!(s, p0)\nprintln(\"\\nNorm of the shooting function: ‚Äñs‚Äñ = \", norm(s), \"\\n\")\nnothing # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We are now ready to solve the shooting equations:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff();\n\nŒæ = p0 # initial guess\nnle! = (s, Œæ) -> shoot!(s, Œæ)\njnle! = (js, Œæ) -> jacobian!(nle!, similar(Œæ), js, backend, Œæ)\n\nindirect_sol = fsolve(nle!, jnle!, Œæ; show_trace=true)\np0 = indirect_sol.x\nnothing # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"shoot!(s, p0)\nprintln(\"\\nNorm of the shooting function: ‚Äñs‚Äñ = \", norm(s), \"\\n\")\nnothing # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Finally, we reconstruct and plot the solution obtained by the indirect method:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"flow_sol = f((0, tf), q0, p0)\nplot!(plt, flow_sol, solution_label=\"(indirect)\")\nnothing # hide","category":"page"},{"location":"index.html#Trjajectorie-in-the-Bloch-sphere","page":"Introduction","title":"Trjajectorie in the Bloch sphere","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Plots\nx = []\ny = []\nz = []\n\nfor t in time_grid(flow_sol)\n    push!(x, state(flow_sol)(t)[1])\n    push!(y, state(flow_sol)(t)[2])\n    push!(z, state(flow_sol)(t)[3])\nend\ngr()\nŒ∏ = 0:0.01:œÄ    \nœÜ = 0:0.01:2œÄ  \nxs = [sin(t) * cos(p) for t in Œ∏, p in œÜ]\nys = [sin(t) * sin(p) for t in Œ∏, p in œÜ]\nzs = [cos(t) for t in Œ∏, p in œÜ]\n\n\n\np = plot(xs, ys, zs, \n    st=:surface, \n    color=:lightblue,\n    alpha=0.5, \n    legend=false, \n    axis = nothing, \n    background_color=:transparent,\n    grid=false,\n)\n\nplot!(x, y, z, lw=2, color=:blue, label=\"Trajectory\")\nscatter!([x[1]], [y[1]], [z[1]], markersize=2, color=:green, label=\"Start\")  \nscatter!([x[end]], [y[end]], [z[end]], markersize=2, color=:red, label=\"End\") ","category":"page"},{"location":"index.html#Reproducibility","page":"Introduction","title":"Reproducibility","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"_downloads_toml(\".\") # hider","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<details style=\"margin-bottom: 0.5em; margin-top: 1em;\"><summary>‚ÑπÔ∏è Version info</summary>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"versioninfo() # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<details style=\"margin-bottom: 0.5em;\"><summary>üì¶ Package status</summary>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pkg.status() # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<details style=\"margin-bottom: 0.5em;\"><summary>üìö Complete manifest</summary>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"</details>","category":"page"}]
}
